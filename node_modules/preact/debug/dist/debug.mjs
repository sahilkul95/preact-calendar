import { checkPropTypes } from 'prop-types';
import { Fragment, options, toChildArray, Component } from 'preact';

/**
 * Get the type/category of a vnode
 * @param {import('../internal').VNode} vnode
 * @returns {import('../internal').NodeType}
 */

function getNodeType(vnode) {
  if (vnode.type === Fragment) { return 'Wrapper'; }else if (typeof vnode.type === 'function') { return 'Composite'; }else if (typeof vnode.type === 'string') { return 'Native'; }
  return 'Text';
}
/**
 * Get human readable name of the component/dom element
 * @param {import('../internal').VNode} vnode
 * @returns {string}
 */

function getDisplayName(vnode) {
  if (vnode.type === Fragment) { return 'Fragment'; }else if (typeof vnode.type === 'function') { return vnode.type.displayName || vnode.type.name; }else if (typeof vnode.type === 'string') { return vnode.type; }
  return '#text';
}
/**
 * Deeply mutate a property by walking down an array of property keys
 * @param {object} obj
 * @param {Array<string | number>} path
 * @param {any} value
 */

function setIn(obj, path, value) {
  var last = path.pop();
  var parent = path.reduce(function (acc, attr) { return acc ? acc[attr] : null; }, obj);

  if (parent) {
    parent[last] = value;
  }
}
/**
 * Get devtools compatible data from vnode
 * @param {import('../internal').VNode} vnode
 * @returns {import('../internal').DevtoolData}
 */

function getData(vnode) {
  var c = vnode._component;
  /** @type {import('../internal').DevtoolsUpdater | null} */

  var updater = null;

  if (c != null) {
    // These functions will be called when the user changes state, props or
    // context values via the devtools ui panel
    updater = {
      setState: c.setState.bind(c),
      forceUpdate: c.forceUpdate.bind(c),

      setInState: function setInState(path, value) {
        c.setState(function (prev) {
          setIn(prev, path, value);
          return prev;
        });
      },

      setInProps: function setInProps(path, value) {
        setIn(vnode.props, path, value);
        c.setState({});
      },

      setInContext: function setInContext(path, value) {
        setIn(c.context, path, value);
        c.setState({});
      }

    };
  }

  var children = getChildren(vnode);
  var duration = vnode.endTime - vnode.startTime;
  return {
    nodeType: getNodeType(vnode),
    type: vnode.type,
    name: getDisplayName(vnode),
    ref: vnode.ref || null,
    key: vnode.key || null,
    updater: updater,
    text: vnode.text,
    state: c != null ? c.state : null,
    props: vnode.props,
    // The devtools inline text children if they are the only child
    children: vnode.text == null ? children != null && children.length == 1 && children[0].text != null ? children[0].text : children : null,
    publicInstance: getInstance(vnode),
    memoizedInteractions: [],
    // Profiler data
    actualDuration: duration,
    actualStartTime: vnode.startTime,
    treeBaseDuration: duration
  };
}
/**
 * Get all rendered vnode children as an array. Moreover we need to filter
 * out `null` or other falsy children.
 * @param {import('../internal').VNode} vnode
 * @returns {import('../internal').VNode[]}
 */

function getChildren(vnode) {
  var c = vnode._component;

  if (c == null) {
    return vnode._children != null ? vnode._children.filter(Boolean) : [];
  }

  return !Array.isArray(c._prevVNode) && c._prevVNode != null ? [c._prevVNode] : null;
}
/**
 * Check if a vnode is a root node
 * @param {import('../internal').VNode} vnode
 * @returns {boolean}
 */

function isRoot(vnode) {
  // Timings of root vnodes will never be set
  return vnode.type === Fragment && vnode.endTime == -1;
}
/**
 * Cache a vnode by its instance and retrieve previous vnodes by the next
 * instance.
 *
 * We need this to be able to identify the previous vnode of a given instance.
 * For components we want to check if we already rendered it and use the class
 * instance as key. For html elements we use the dom node as key.
 *
 * @param {import('../internal').VNode} vnode
 * @returns {import('../internal').Component | import('../internal').PreactElement | Text | null}
 */

function getInstance(vnode) {
  // Use the parent element as instance for root nodes
  if (isRoot(vnode)) {
    // Edge case: When the tree only consists of components that have not rendered
    // anything into the DOM we revert to using the vnode as instance.
    return vnode._children.length > 0 && vnode._children[0]._dom != null ?
    /** @type {import('../internal').PreactElement | null} */
    vnode._children[0]._dom.parentNode : vnode;
  }

  if (vnode._component != null) { return vnode._component; }
  if (vnode.type === Fragment) { return vnode.props; }
  return vnode._dom;
}
/**
 * Compare two objects
 * @param {object} a
 * @param {object} b
 * @param {boolean} [isProps]
 * @returns {boolean}
 */

function shallowEqual(a, b, isProps) {
  if (a == null || b == null) { return false; }

  for (var key in a) {
    if (isProps && key == 'children' && b[key] != null) { continue; }
    if (a[key] !== b[key]) { return false; }
  }

  if (Object.keys(a).length !== Object.keys(b).length) { return false; }
  return true;
}
/**
 * Check if a vnode was actually updated
 * @param {import('../internal').VNode} next
 * @param {import('../internal').VNode} prev
 * @returns {boolean}
 */

function hasDataChanged(prev, next) {
  return prev.props !== next.props && !shallowEqual(prev.props, next.props, true) || prev._component != null && !shallowEqual(next._component._prevState, next._component.state) || prev._dom !== next._dom || prev.ref !== next.ref;
}
/**
 * Check if a the profiling data ahs changed between vnodes
 * @param {import('../internal').VNode} next
 * @param {import('../internal').VNode} prev
 * @returns {boolean}
 */

function hasProfileDataChanged(prev, next) {
  return prev.startTime !== next.startTime || prev.endTime !== next.endTime;
}

function initDebug() {
  /* eslint-disable no-console */
  var oldBeforeDiff = options.diff;

  options.diff = function (vnode) {
    var type = vnode.type;
    var props = vnode.props;
    var children = props && props.children;

    if (type === undefined) {
      throw new Error('Undefined component passed to createElement()\n' + serializeVNode(vnode));
    }

    if (vnode.ref !== undefined && typeof vnode.ref !== 'function' && typeof vnode.ref !== 'object' && !('$$typeof' in vnode) // allow string refs when preact-compat is installed
    ) {
        throw new Error("Component's \"ref\" property should be a function, or an object created " + "by createRef(), but got [" + (typeof vnode.ref) + "] instead\n" + serializeVNode(vnode));
      } // Check prop-types if available


    if (typeof vnode.type === 'function' && vnode.type.propTypes) {
      checkPropTypes(vnode.type.propTypes, vnode.props, getDisplayName(vnode), serializeVNode(vnode));
    }

    var keys = [];

    for (var i = 0, list = toChildArray(children); i < list.length; i += 1) {
      var deepChild = list[i];

      if (!deepChild || deepChild.key == null) { continue; }
      var key = deepChild.key;

      if (keys.indexOf(key) !== -1) {
        console.error('Following component has two or more children with the ' + "same key attribute: \"" + key + "\". This may cause glitches and misbehavior " + 'in rendering process. Component: \n\n' + serializeVNode(vnode)); // Break early to not spam the console

        break;
      }

      keys.push(key);
    }

    if (oldBeforeDiff) { oldBeforeDiff(vnode); }
  };
}
/**
 * Serialize a vnode tree to a string
 * @param {import('./internal').VNode} vnode
 * @returns {string}
 */

function serializeVNode(vnode) {
  var props = vnode.props;
  var name = getDisplayName(vnode);
  var attrs = '';

  if (props) {
    for (var prop in props) {
      if (props.hasOwnProperty(prop) && prop !== 'children') {
        var value = props[prop]; // If it is an object but doesn't have toString(), use Object.toString

        if (typeof value === 'function') {
          value = "function " + (value.displayName || value.name) + "() {}";
        }

        value = Object(value) === value && !value.toString ? Object.prototype.toString.call(value) : value + '';
        attrs += " " + prop + "=" + (JSON.stringify(value));
      }
    }
  }

  var children = props.children;
  return ("<" + name + attrs + (children && children.length ? '>..</' + name + '>' : ' />'));
}

/**
 * Custom renderer tailored for Preact. It converts updated vnode trees
 * to events the devtools can understand.
 * @class Renderer
 */

var Renderer = function Renderer(hook, rid) {
  /** @type {string} */
  this.rid = rid;
  this.hook = hook;
  /** @type {Array<import('../internal').DevtoolsEvent>} */

  this.pending = [];
  /**
   * Store the instance of a vnode. This will be later used to decide if a
   * vnode needs to be mounted or updated. For components the instance refers
   * to the actuall class instance whereas for dom nodes it refers to the
   * underlying dom element.
   * @type {WeakMap<import('../internal').Component | import('../internal').PreactElement | HTMLElement | Text, import('../internal').VNode>}
   */

  this.inst2vnode = new WeakMap();
  this.connected = false;
};
/**
 * Mark the connection status as ready so that we can proceed
 * to actually flush events.
 */


Renderer.prototype.markConnected = function markConnected () {
  this.connected = true;
  this.flushPendingEvents();
};
/**
 * Flush all queued events
 */


Renderer.prototype.flushPendingEvents = function flushPendingEvents () {
  if (!this.connected) { return; }
  var events = this.pending;
  this.pending = [];

  for (var i = 0; i < events.length; i++) {
    var event = events[i];
    this.hook.emit(event.type, event);
  }
};
/**
 * Recursively mount a vnode tree. Note that the devtools expectes the tree to
 * be mounted from the bottom up, otherwise the order will be messed up.
 * Therefore we mount children prior to mounting the vnode itself.
 * @param {import('../internal').VNode} vnode
 */


Renderer.prototype.mount = function mount (vnode) {
  this.inst2vnode.set(getInstance(vnode), vnode);
  var data = getData(vnode);
  /** @type {Array<import('../internal').DevtoolsEvent>} */

  var work = [{
    internalInstance: vnode,
    data: data,
    renderer: this.rid,
    type: 'mount'
  }]; // Children must be mounted first

  if (Array.isArray(data.children)) {
    var stack = data.children.slice();
    var item;

    while ((item = stack.pop()) != null) {
      var children = getChildren(item);
      stack.push.apply(stack, children);
      this.inst2vnode.set(getInstance(item), item);
      var data$1 = getData(item);
      work.push({
        internalInstance: item,
        data: data$1,
        renderer: this.rid,
        type: 'mount'
      });
    }
  }

  for (var i = work.length; --i >= 0;) {
    this.pending.push(work[i]);
  } // Special event if we have a root


  if (isRoot(vnode)) {
    this.pending.push({
      internalInstance: vnode,
      data: data,
      renderer: this.rid,
      type: 'root'
    });
  }
};
/**
 * Update a vnode tree
 * @param {import('../internal').VNode} vnode
 */


Renderer.prototype.update = function update (vnode) {
  var data = getData(vnode); // Children must be updated first

  if (Array.isArray(data.children)) {
    for (var i = 0; i < data.children.length; i++) {
      var child = data.children[i];
      var inst = getInstance(child);
      var prevChild = this.inst2vnode.get(inst);
      if (prevChild == null) { this.mount(child); }else { this.update(child); } // Mutate child to keep referential equality intact

      data.children[i] = this.inst2vnode.get(inst);
    }
  }

  var prev = this.inst2vnode.get(data.publicInstance); // The `updateProfileTimes` event is a faster version of `updated` and
  // is processed much quicker inside the devtools extension.

  if (!hasDataChanged(prev, vnode) && hasProfileDataChanged(prev, vnode)) {
    this.pending.push({
      // This property is only used as an id inside the devtools. The
      // relevant data will be read from `.data` instead which is a
      // normalized structure that every react release adheres to. This
      // makes backwards-compatibility easier instead of relying on internal
      // vnode/fiber shape.
      internalInstance: prev,
      data: data,
      renderer: this.rid,
      type: 'updateProfileTimes'
    });
    return;
  }

  this.pending.push({
    // This property is only used as an id inside the devtools. The
    // relevant data will be read from `.data` instead which is a
    // normalized structure that every react release adheres to. This
    // makes backwards-compatibility easier instead of relying on internal
    // vnode/fiber shape.
    internalInstance: prev,
    data: data,
    renderer: this.rid,
    type: 'update'
  });
};
/**
 * Pass a rendered tree to the devtools. At this point elements have already
 * unmounted, so we don't need to check for removals and only update vs mount
 * instead.
 * @param {import('../internal').VNode} vnode
 */


Renderer.prototype.handleCommitFiberRoot = function handleCommitFiberRoot (vnode) {
  var inst = getInstance(vnode);
  if (this.inst2vnode.has(inst)) { this.update(vnode); }else { this.mount(vnode); } // The devtools checks via the existance of this property if the devtools
  // profiler should be enabled or not. If it is missing from the first root
  // node the "Profiler" tab won't show up.

  /** @type {import('../internal').VNode} */

  var root = null;

  if (isRoot(vnode)) {
    /** @type {*} */
    vnode.treeBaseDuration = 0;
    root = vnode;
  } else {
    // "rootCommitted" always needs the actual root node for the profiler
    // to be able to collect timings. The `_ancestorComponent` property will
    // point to a vnode for a root node.
    root = vnode._component;

    while (root._ancestorComponent != null) {
      root = root._ancestorComponent;
    }
  }

  this.pending.push({
    internalInstance: root,
    renderer: this.rid,
    data: getData(root),
    type: 'rootCommitted'
  });
  this.flushPendingEvents();
  return vnode;
};
/**
 * Unmount a vnode recursively. Contrary to mounting or updating unmounting needs
 * to push the events in parent-first order. Because `options.unmount` is
 * already fired in parent-first order we don't need to traverse anything here.
 * @param {import('../internal').VNode} vnode
 */


Renderer.prototype.handleCommitFiberUnmount = function handleCommitFiberUnmount (vnode) {
  var inst = getInstance(vnode);
  this.inst2vnode.delete(inst); // Special case when unmounting a root (most prominently caused by webpack's
  // `hot-module-reloading`). If this happens we need to unmount the virtual
  // `Fragment` we're wrapping around each root just for the devtools.

  this.pending.push({
    internalInstance: vnode,
    renderer: this.rid,
    type: 'unmount'
  });
};
/**
 * Get the dom element by a vnode
 * @param {import('../internal').VNode} vnode
 * @returns {import('../internal').PreactElement | Text}
 */


Renderer.prototype.getNativeFromReactElement = function getNativeFromReactElement (vnode) {
  return vnode._dom;
};
/**
 * Get a vnode by a dom element
 * @param {import('../internal').PreactElement | Text} dom
 * @returns {import('../internal').VNode | null}
 */


Renderer.prototype.getReactElementFromNative = function getReactElementFromNative (dom) {
  return this.inst2vnode.get(dom) || null;
}; // Unused, but devtools expects it to be there

/* istanbul ignore next */


Renderer.prototype.walkTree = function walkTree () {}; // Unused, but devtools expects it to be there

/* istanbul ignore next */


Renderer.prototype.cleanup = function cleanup () {};

/**
 * Wrap function with generic error logging
 *
 * @param {*} fn
 * @returns
 */

function catchErrors(fn) {
  return function (arg) {
    try {
      return fn(arg);
    } catch (e) {
      /* istanbul ignore next */
      console.error('The react devtools encountered an error');
      /* istanbul ignore next */

      console.error(e); // eslint-disable-line no-console
    }
  };
}
/* istanbul ignore next */


var noop = function () { return undefined; };

function initDevTools() {
  // This global variable is injected by the devtools

  /** @type {import('../internal').DevtoolsWindow} */
  var hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (hook == null) { return; }
  /** @type {(vnode: import('../internal').VNode) => void} */

  var onCommitRoot = noop;
  /** @type {(vnode: import('../internal').VNode) => void} */

  var onCommitUnmount = noop; // Initialize our custom renderer

  var rid = Math.random().toString(16).slice(2);
  var preactRenderer = new Renderer(hook, rid);
  catchErrors(function () {
    var isDev = false;

    try {
      isDev = process.env.NODE_ENV !== 'production';
    } catch (e) {} // Tell devtools which bundle type we run in


    window.parent.postMessage({
      source: 'react-devtools-detector',
      reactBuildType:
      /* istanbul ignore next */
      isDev ? 'development' : 'production'
    }, '*');
    var renderer = {
      bundleType:
      /* istanbul ignore next */
      isDev ? 1 : 0,
      version: '16.5.2',
      rendererPackageName: 'preact',

      // We don't need this, but the devtools `attachRenderer` function relys
      // it being there.
      findHostInstanceByFiber: function findHostInstanceByFiber(vnode) {
        return vnode._dom;
      },

      // We don't need this, but the devtools `attachRenderer` function relys
      // it being there.
      findFiberByHostInstance: function findFiberByHostInstance(instance) {
        return preactRenderer.inst2vnode.get(instance) || null;
      }

    };
    hook._renderers[rid] = renderer; // We can't bring our own `attachRenderer` function therefore we simply
    // prevent the devtools from overwriting our custom renderer by creating
    // a noop setter.

    Object.defineProperty(hook.helpers, rid, {
      get: function () { return preactRenderer; },
      set: function () {
        if (!preactRenderer.connected) {
          helpers.markConnected();
        }
      }
    });
    var helpers = hook.helpers[rid]; // Tell the devtools that we are ready to start

    hook.emit('renderer-attached', {
      id: rid,
      renderer: renderer,
      helpers: helpers
    });
    onCommitRoot = catchErrors(function (root) {
      // Empty root
      if (root.type === Fragment && root._children.length == 0) { return; }
      var roots = hook.getFiberRoots(rid);
      root = helpers.handleCommitFiberRoot(root);
      if (!roots.has(root)) { roots.add(root); }
    });
    onCommitUnmount = catchErrors(function (vnode) {
      hook.onCommitFiberUnmount(rid, vnode);
    });
  })(); // Store (possible) previous hooks so that we don't overwrite them

  var prevVNodeHook = options.vnode;
  var prevCommitRoot = options.commit;
  var prevBeforeUnmount = options.unmount;
  var prevBeforeDiff = options.diff;
  var prevAfterDiff = options.diffed;

  options.vnode = function (vnode) {
    // Tiny performance improvement by initializing fields as doubles
    // from the start. `performance.now()` will always return a double.
    // See https://github.com/facebook/react/issues/14365
    // and https://slidr.io/bmeurer/javascript-engine-fundamentals-the-good-the-bad-and-the-ugly
    vnode.startTime = NaN;
    vnode.endTime = NaN;
    vnode.startTime = 0;
    vnode.endTime = -1;
    if (prevVNodeHook) { prevVNodeHook(vnode); }
  };

  options.diff = function (vnode) {
    vnode.startTime = now();
    if (prevBeforeDiff != null) { prevBeforeDiff(vnode); }
  };

  options.diffed = function (vnode) {
    vnode.endTime = now();
    if (prevAfterDiff != null) { prevAfterDiff(vnode); }
  };

  options.commit = catchErrors(function (vnode) {
    // Call previously defined hook
    if (prevCommitRoot != null) { prevCommitRoot(vnode); } // These cases are already handled by `unmount`

    if (vnode == null) { return; }
    onCommitRoot(vnode);
  });
  options.unmount = catchErrors(function (vnode) {
    // Call previously defined hook
    if (prevBeforeUnmount != null) { prevBeforeUnmount(vnode); }
    onCommitUnmount(vnode);
  }); // Inject tracking into setState

  var setState = Component.prototype.setState;

  Component.prototype.setState = function (update, callback) {
    // Duplicated in setState() but doesn't matter due to the guard.
    var s = this._nextState !== this.state && this._nextState || (this._nextState = Object.assign({}, this.state)); // Needed in order to check if state has changed after the tree has been committed:

    this._prevState = Object.assign({}, s);
    return setState.call(this, update, callback);
  };
}
/**
 * Get current timestamp in ms. Used for profiling.
 * @returns {number}
 */

var now = Date.now;

try {
  /* istanbul ignore else */
  now = performance.now.bind(performance);
} catch (e) {}

if (process.env.NODE_ENV === 'development') {
  initDebug();
  initDevTools();
}
//# sourceMappingURL=debug.mjs.map
