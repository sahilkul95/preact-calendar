"use strict";

var n = require("preact"),
    e = {};function t(e) {
  return e.type === n.Fragment ? "Wrapper" : "function" == typeof e.type ? "Composite" : "string" == typeof e.type ? "Native" : "Text";
}function r(e) {
  return e.type === n.Fragment ? "Fragment" : "function" == typeof e.type ? e.type.displayName || e.type.name : "string" == typeof e.type ? e.type : "#text";
}function o(n, e, t) {
  var r = e.pop(),
      o = e.reduce(function (n, e) {
    return n ? n[e] : null;
  }, n);o && (o[r] = t);
}function i(e) {
  var i = e.__c,
      u = null;null != i && i instanceof n.Component && (u = { setState: i.setState.bind(i), forceUpdate: i.forceUpdate.bind(i), setInState: function setInState(n, e) {
      i.setState(function (t) {
        return o(t, n, e), t;
      });
    }, setInProps: function setInProps(n, t) {
      o(e.props, n, t), i.setState({});
    }, setInContext: function setInContext(n, e) {
      o(i.context, n, e), i.setState({});
    } });var s = a(e),
      c = e.endTime - e.startTime;return { nodeType: t(e), type: e.type, name: r(e), ref: e.ref || null, key: e.key || null, updater: u, text: null === e.type ? e.props : null, state: null != i && i instanceof n.Component ? i.state : null, props: e.props, children: null !== e.type ? null != s && 1 == s.length && null === s[0].type ? s[0].props : s : null, publicInstance: l(e), memoizedInteractions: [], actualDuration: c, actualStartTime: e.startTime, treeBaseDuration: c };
}function a(n) {
  return null == n.__c ? null != n.__k ? n.__k.filter(Boolean) : [] : null != n.__k ? n.__k.filter(Boolean) : null;
}function u(e) {
  return e.type === n.Fragment && null === e.__p;
}function l(e) {
  return u(e) ? e.__k.length > 0 && null != e.__k[0] && null != e.__k[0].__e ? e.__k[0].__e.parentNode : e : null != e.__c ? e.__c : e.type === n.Fragment ? e.props : e.__e;
}function s(n, e, t) {
  if (null == n || null == e) return !1;for (var r in n) {
    if ((!t || "children" != r || null == e[r]) && n[r] !== e[r]) return !1;
  }return Object.keys(n).length === Object.keys(e).length;
}function c(n) {
  var e = n.props,
      t = r(n),
      o = "";if (e) for (var i in e) {
    if (e.hasOwnProperty(i) && "children" !== i) {
      var a = e[i];"function" == typeof a && (a = "function " + (a.displayName || a.name) + "() {}"), a = Object(a) !== a || a.toString ? a + "" : Object.prototype.toString.call(a), o += " " + i + "=" + JSON.stringify(a);
    }
  }var u = e.children;return "<" + t + o + (u && u.length ? ">..</" + t + ">" : " />");
}var f = function f(n, e) {
  this.rid = e, this.hook = n, this.pending = [], this.inst2vnode = new WeakMap(), this.connected = !1;
};function d(n) {
  return function (e) {
    try {
      return n(e);
    } catch (n) {
      console.error("The react devtools encountered an error"), console.error(n);
    }
  };
}f.prototype.markConnected = function () {
  this.connected = !0, this.flushPendingEvents();
}, f.prototype.flushPendingEvents = function () {
  if (this.connected) {
    var n = this.pending;this.pending = [];for (var e = 0; e < n.length; e++) {
      var t = n[e];this.hook.emit(t.type, t);
    }
  }
}, f.prototype.mount = function (n) {
  this.inst2vnode.set(l(n), n);var e = i(n),
      t = [{ internalInstance: n, data: e, renderer: this.rid, type: "mount" }];if (Array.isArray(e.children)) for (var r, o = e.children.slice(); null != (r = o.pop());) {
    var s = a(r);o.push.apply(o, s), this.inst2vnode.set(l(r), r);var c = i(r);t.push({ internalInstance: r, data: c, renderer: this.rid, type: "mount" });
  }for (var f = t.length; --f >= 0;) {
    this.pending.push(t[f]);
  }u(n) && this.pending.push({ internalInstance: n, data: e, renderer: this.rid, type: "root" });
}, f.prototype.update = function (n) {
  var e = i(n);if (Array.isArray(e.children)) for (var t = 0; t < e.children.length; t++) {
    var r = e.children[t],
        o = l(r);null == this.inst2vnode.get(o) ? this.mount(r) : this.update(r), e.children[t] = this.inst2vnode.get(o);
  }var a = this.inst2vnode.get(e.publicInstance);!function (n, e) {
    return n.props !== e.props && !s(n.props, e.props, !0) || null != n.__c && !s(e.__c.__u, e.__c.state) || n.__e !== e.__e || n.ref !== e.ref;
  }(a, n) ? this.pending.push({ internalInstance: a, data: e, renderer: this.rid, type: "updateProfileTimes" }) : this.pending.push({ internalInstance: a, data: e, renderer: this.rid, type: "update" });
}, f.prototype.handleCommitFiberRoot = function (n) {
  var e = l(n);this.inst2vnode.has(e) ? this.update(n) : this.mount(n);var t = null;if (u(n)) n.treeBaseDuration = 0, t = n;else for (t = n; null != t.__p;) {
    t = t.__p;
  }return this.pending.push({ internalInstance: t, renderer: this.rid, data: i(t), type: "rootCommitted" }), this.flushPendingEvents(), n;
}, f.prototype.handleCommitFiberUnmount = function (n) {
  var e = l(n);this.inst2vnode.delete(e), this.pending.push({ internalInstance: n, renderer: this.rid, type: "unmount" });
}, f.prototype.getNativeFromReactElement = function (n) {
  return n.__e;
}, f.prototype.getReactElementFromNative = function (n) {
  return this.inst2vnode.get(n) || null;
}, f.prototype.walkTree = function () {}, f.prototype.cleanup = function () {};var h = function h() {},
    p = Date.now;try {
  p = performance.now.bind(performance);
} catch (n) {}"development" === process.env.NODE_ENV && (function () {
  var t = n.options.__b,
      o = n.options.diffed,
      i = n.options.vnode,
      a = n.options.__e,
      u = { useEffect: {}, useLayoutEffect: {}, lazyPropTypes: {} };n.options.__e = function (n, e, t) {
    if (e && e.__c && "function" == typeof n.then) {
      var o = n;n = new Error("Missing Suspense. The throwing component was: " + r(e));for (var i = e; i; i = i.__p) {
        if (i.__c && i.__c.t) {
          n = o;break;
        }
      }
    }a(n, e, t);
  }, n.options.__p = function (n, e) {
    if (!e) throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");var t;switch (e.nodeType) {case 1:case 11:case 9:
        t = !0;break;default:
        t = !1;}if (!t) throw new Error("\n\t\t\tExpected a valid HTML node as a second argument to render.\n\t\t\tReceived " + e + " instead: render(<" + (n.type.name || n.type) + " />, " + e + ");\n\t\t");
  }, n.options.__b = function (n) {
    if (null != n) {
      var o,
          i,
          a,
          l,
          s = n.type,
          f = function n(e) {
        return e ? "function" == typeof e.type ? n(e.__p) : e : {};
      }(n.__p);if (void 0 === s) throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports" + c(n));if (null != s && "object" == typeof s) {
        if (void 0 !== s.o && void 0 !== s.__e) {
          var d = "Did you accidentally pass a JSX literal as JSX twice?\n\n  let My" + r(s) + " = " + c(s) + ";\n  let vnode = <My" + r(s) + " />;\n\nThis usually happens when you export a JSX literal and not the component.";throw new Error("Invalid type passed to createElement(): " + s + "\n\n" + d + "\n");
        }throw new Error("Invalid type passed to createElement(): " + (Array.isArray(s) ? "array" : s));
      }if ("thead" !== s && "tfoot" !== s && "thead" !== s || "table" === f.type ? "tr" === s && "thead" !== f.type && "tfoot" !== f.type && "tbody" !== f.type && "table" !== f.type ? console.error("Improper nesting of table.Your <tr> should have a <thead/tbody/tfoot/table> parent." + c(n)) : "td" === s && "tr" !== f.type ? console.error("Improper nesting of table.Your <td> should have a <tr> parent." + c(n)) : "th" === s && "tr" !== f.type && console.error("Improper nesting of table.Your <th> should have a <tr>." + c(n)) : console.error("Improper nesting of table.Your <thead/tbody/tfoot> should have a <table> parent." + c(n)), void 0 !== n.ref && "function" != typeof n.ref && "object" != typeof n.ref && !("$$typeof" in n)) throw new Error('Component\'s "ref" property should be a function, or an object created by createRef(), but got [' + typeof n.ref + "] instead\n" + c(n));if ("string" == typeof n.type) for (var h in n.props) {
        if ("o" === h[0] && "n" === h[1] && "function" != typeof n.props[h] && null != n.props[h]) throw new Error("Component's \"" + h + '" property should be a function, but got [' + typeof n.props[h] + "] instead\n" + c(n));
      }if ("function" == typeof n.type && n.type.propTypes) {
        if ("Lazy" === n.type.displayName && !u.lazyPropTypes[n.type]) {
          var p = "PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";try {
            var v = n.type();u.lazyPropTypes[n.type] = !0, console.warn(p + "Component wrapped in lazy() is " + (v.type.displayName || v.type.name));
          } catch (n) {
            console.warn(p + "We will log the wrapped component's name once it is loaded.");
          }
        }o = n.type.propTypes, i = n.props, a = r(n), l = c(n), Object.keys(o).forEach(function (n) {
          var t;try {
            t = o[n](i, n, l, a, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
          } catch (n) {
            t = n;
          }!t || t.message in e || (e[t.message] = !0, console.error("Failed " + a + " type: " + t.message));
        });
      }t && t(n);
    }
  }, n.options.__h = function (n) {
    if (!n) throw new Error("Hook can only be invoked from render methods.");
  };var l = function l(n, e) {
    return { get: function get() {
        throw new Error("getting vnode." + n + " is deprecated, " + e);
      }, set: function set() {
        throw new Error("setting vnode." + n + " is not allowed, " + e);
      } };
  },
      s = { nodeName: l("nodeName", "use vnode.type"), attributes: l("attributes", "use vnode.props"), children: l("children", "use vnode.props.children") };n.options.vnode = function (n) {
    var e, t;n.props && n.props.i && (e = n.props.i, delete n.props.i), n.props && n.props.u && (t = n.props.u, delete n.props.u), n.u = t, n.i = e, Object.defineProperties(n, s), i && i(n);
  }, n.options.diffed = function (n) {
    if (null != n) {
      if (n.__c && n.__c.l) {
        var e = n.__c.l;e.s.forEach(function (e) {
          !e.h || e.p && Array.isArray(e.p) || console.warn("In " + (n.type.name || n.type) + " you are calling useMemo/useCallback without passing arguments.\nThis is a noop since it will not be able to memoize, it will execute it every render.");
        }), e.v.length > 0 && e.v.forEach(function (e) {
          e.p && Array.isArray(e.p) || u.useEffect[n.type] || (u.useEffect[n.type] = !0, console.warn('You should provide an array of arguments as the second argument to the "useEffect" hook.\n\nNot doing so will invoke this effect on every render.\n\nThis effect can be found in the render of ' + (n.type.name || n.type) + "."));
        }), e.m.length > 0 && e.m.forEach(function (e) {
          e.p && Array.isArray(e.p) || u.useLayoutEffect[n.type] || (u.useLayoutEffect[n.type] = !0, console.warn('You should provide an array of arguments as the second argument to the "useLayoutEffect" hook.\n\nNot doing so will invoke this effect on every render.\n\nThis effect can be found in the render of ' + (n.type.name || n.type) + "."));
        });
      }if (null != n.__k) for (var t = [], r = 0; r < n.__k.length; r++) {
        var i = n.__k[r];if (i && null != i.key) {
          var a = i.key;if (-1 !== t.indexOf(a)) {
            console.error('Following component has two or more children with the same key attribute: "' + a + '". This may cause glitches and misbehavior in rendering process. Component: \n\n' + c(n));break;
          }t.push(a);
        }
      }o && o(n);
    }
  };
}(), function () {
  var e = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;if (null != e) {
    var t = h,
        r = h,
        o = Math.random().toString(16).slice(2),
        i = new f(e, o);d(function () {
      var a = !1;try {
        a = "production" !== process.env.NODE_ENV;
      } catch (n) {}window.parent.postMessage({ source: "react-devtools-detector", reactBuildType: a ? "development" : "production" }, "*");var u = { bundleType: a ? 1 : 0, version: "16.5.2", rendererPackageName: "preact", findHostInstanceByFiber: function findHostInstanceByFiber(n) {
          return n.__e;
        }, findFiberByHostInstance: function findFiberByHostInstance(n) {
          return i.inst2vnode.get(n) || null;
        } };e._renderers[o] = u, Object.defineProperty(e.helpers, o, { get: function get() {
          return i;
        }, set: function set() {
          i.connected || l.markConnected();
        } });var l = e.helpers[o];e.emit("renderer-attached", { id: o, renderer: u, helpers: l }), t = d(function (t) {
        if (t.type !== n.Fragment || 0 != t.__k.length) {
          var r = e.getFiberRoots(o);t = l.handleCommitFiberRoot(t), r.has(t) || r.add(t);
        }
      }), r = d(function (n) {
        e.onCommitFiberUnmount(o, n);
      });
    })();var a = n.options.vnode,
        u = n.options.__c,
        l = n.options.unmount,
        s = n.options.__b,
        c = n.options.diffed;n.options.vnode = function (n) {
      n.startTime = NaN, n.endTime = NaN, n.startTime = 0, n.endTime = -1, a && a(n);
    }, n.options.__b = function (n) {
      n.startTime = p(), null != s && s(n);
    }, n.options.diffed = function (n) {
      n.endTime = p(), null != c && c(n);
    }, n.options.__c = d(function (n) {
      null != u && u(n), null != n && t(n);
    }), n.options.unmount = d(function (n) {
      null != l && l(n), r(n);
    });var v = n.Component.prototype.setState;n.Component.prototype.setState = function (n, e) {
      var t = this.__s !== this.state && this.__s || (this.__s = Object.assign({}, this.state));return this.__u = Object.assign({}, t), v.call(this, n, e);
    };
  }
}());
//# sourceMappingURL=debug.js.map
"use strict";

var _preact = require("preact");

var r = {};function o(n) {
  return n.type === _preact.Fragment ? "Wrapper" : "function" == typeof n.type ? "Composite" : "string" == typeof n.type ? "Native" : "Text";
}function i(n) {
  return n.type === _preact.Fragment ? "Fragment" : "function" == typeof n.type ? n.type.displayName || n.type.name : "string" == typeof n.type ? n.type : "#text";
}function a(n, e, t) {
  var r = e.pop(),
      o = e.reduce(function (n, e) {
    return n ? n[e] : null;
  }, n);o && (o[r] = t);
}function u(e) {
  var t = e.__c,
      r = null;null != t && t instanceof _preact.Component && (r = { setState: t.setState.bind(t), forceUpdate: t.forceUpdate.bind(t), setInState: function setInState(n, e) {
      t.setState(function (t) {
        return a(t, n, e), t;
      });
    }, setInProps: function setInProps(n, r) {
      a(e.props, n, r), t.setState({});
    }, setInContext: function setInContext(n, e) {
      a(t.context, n, e), t.setState({});
    } });var u = l(e),
      s = e.endTime - e.startTime;return { nodeType: o(e), type: e.type, name: i(e), ref: e.ref || null, key: e.key || null, updater: r, text: null === e.type ? e.props : null, state: null != t && t instanceof _preact.Component ? t.state : null, props: e.props, children: null !== e.type ? null != u && 1 == u.length && null === u[0].type ? u[0].props : u : null, publicInstance: c(e), memoizedInteractions: [], actualDuration: s, actualStartTime: e.startTime, treeBaseDuration: s };
}function l(n) {
  return null == n.__c ? null != n.__k ? n.__k.filter(Boolean) : [] : null != n.__k ? n.__k.filter(Boolean) : null;
}function s(n) {
  return n.type === _preact.Fragment && null === n.__p;
}function c(n) {
  return s(n) ? n.__k.length > 0 && null != n.__k[0] && null != n.__k[0].__e ? n.__k[0].__e.parentNode : n : null != n.__c ? n.__c : n.type === _preact.Fragment ? n.props : n.__e;
}function f(n, e, t) {
  if (null == n || null == e) return !1;for (var r in n) {
    if ((!t || "children" != r || null == e[r]) && n[r] !== e[r]) return !1;
  }return Object.keys(n).length === Object.keys(e).length;
}function d(n) {
  var e = n.props,
      t = i(n),
      r = "";if (e) for (var o in e) {
    if (e.hasOwnProperty(o) && "children" !== o) {
      var a = e[o];"function" == typeof a && (a = "function " + (a.displayName || a.name) + "() {}"), a = Object(a) !== a || a.toString ? a + "" : Object.prototype.toString.call(a), r += " " + o + "=" + JSON.stringify(a);
    }
  }var u = e.children;return "<" + t + r + (u && u.length ? ">..</" + t + ">" : " />");
}var h = function h(n, e) {
  this.rid = e, this.hook = n, this.pending = [], this.inst2vnode = new WeakMap(), this.connected = !1;
};function p(n) {
  return function (e) {
    try {
      return n(e);
    } catch (n) {
      console.error("The react devtools encountered an error"), console.error(n);
    }
  };
}h.prototype.markConnected = function () {
  this.connected = !0, this.flushPendingEvents();
}, h.prototype.flushPendingEvents = function () {
  if (this.connected) {
    var n = this.pending;this.pending = [];for (var e = 0; e < n.length; e++) {
      var t = n[e];this.hook.emit(t.type, t);
    }
  }
}, h.prototype.mount = function (n) {
  this.inst2vnode.set(c(n), n);var e = u(n),
      t = [{ internalInstance: n, data: e, renderer: this.rid, type: "mount" }];if (Array.isArray(e.children)) for (var r, o = e.children.slice(); null != (r = o.pop());) {
    var i = l(r);o.push.apply(o, i), this.inst2vnode.set(c(r), r);var a = u(r);t.push({ internalInstance: r, data: a, renderer: this.rid, type: "mount" });
  }for (var f = t.length; --f >= 0;) {
    this.pending.push(t[f]);
  }s(n) && this.pending.push({ internalInstance: n, data: e, renderer: this.rid, type: "root" });
}, h.prototype.update = function (n) {
  var e = u(n);if (Array.isArray(e.children)) for (var t = 0; t < e.children.length; t++) {
    var r = e.children[t],
        o = c(r);null == this.inst2vnode.get(o) ? this.mount(r) : this.update(r), e.children[t] = this.inst2vnode.get(o);
  }var i = this.inst2vnode.get(e.publicInstance);!function (n, e) {
    return n.props !== e.props && !f(n.props, e.props, !0) || null != n.__c && !f(e.__c.__u, e.__c.state) || n.__e !== e.__e || n.ref !== e.ref;
  }(i, n) ? this.pending.push({ internalInstance: i, data: e, renderer: this.rid, type: "updateProfileTimes" }) : this.pending.push({ internalInstance: i, data: e, renderer: this.rid, type: "update" });
}, h.prototype.handleCommitFiberRoot = function (n) {
  var e = c(n);this.inst2vnode.has(e) ? this.update(n) : this.mount(n);var t = null;if (s(n)) n.treeBaseDuration = 0, t = n;else for (t = n; null != t.__p;) {
    t = t.__p;
  }return this.pending.push({ internalInstance: t, renderer: this.rid, data: u(t), type: "rootCommitted" }), this.flushPendingEvents(), n;
}, h.prototype.handleCommitFiberUnmount = function (n) {
  var e = c(n);this.inst2vnode.delete(e), this.pending.push({ internalInstance: n, renderer: this.rid, type: "unmount" });
}, h.prototype.getNativeFromReactElement = function (n) {
  return n.__e;
}, h.prototype.getReactElementFromNative = function (n) {
  return this.inst2vnode.get(n) || null;
}, h.prototype.walkTree = function () {}, h.prototype.cleanup = function () {};var v = function v() {},
    y = Date.now;try {
  y = performance.now.bind(performance);
} catch (n) {}"development" === process.env.NODE_ENV && (function () {
  var n = _preact.options.__b,
      e = _preact.options.diffed,
      o = _preact.options.vnode,
      a = _preact.options.__e,
      u = { useEffect: {}, useLayoutEffect: {}, lazyPropTypes: {} };_preact.options.__e = function (n, e, t) {
    if (e && e.__c && "function" == typeof n.then) {
      var r = n;n = new Error("Missing Suspense. The throwing component was: " + i(e));for (var o = e; o; o = o.__p) {
        if (o.__c && o.__c.t) {
          n = r;break;
        }
      }
    }a(n, e, t);
  }, _preact.options.__p = function (n, e) {
    if (!e) throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");var t;switch (e.nodeType) {case 1:case 11:case 9:
        t = !0;break;default:
        t = !1;}if (!t) throw new Error("\n\t\t\tExpected a valid HTML node as a second argument to render.\n\t\t\tReceived " + e + " instead: render(<" + (n.type.name || n.type) + " />, " + e + ");\n\t\t");
  }, _preact.options.__b = function (e) {
    if (null != e) {
      var t,
          o,
          a,
          l,
          s = e.type,
          c = function n(e) {
        return e ? "function" == typeof e.type ? n(e.__p) : e : {};
      }(e.__p);if (void 0 === s) throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports" + d(e));if (null != s && "object" == typeof s) {
        if (void 0 !== s.o && void 0 !== s.__e) {
          var f = "Did you accidentally pass a JSX literal as JSX twice?\n\n  let My" + i(s) + " = " + d(s) + ";\n  let vnode = <My" + i(s) + " />;\n\nThis usually happens when you export a JSX literal and not the component.";throw new Error("Invalid type passed to createElement(): " + s + "\n\n" + f + "\n");
        }throw new Error("Invalid type passed to createElement(): " + (Array.isArray(s) ? "array" : s));
      }if ("thead" !== s && "tfoot" !== s && "thead" !== s || "table" === c.type ? "tr" === s && "thead" !== c.type && "tfoot" !== c.type && "tbody" !== c.type && "table" !== c.type ? console.error("Improper nesting of table.Your <tr> should have a <thead/tbody/tfoot/table> parent." + d(e)) : "td" === s && "tr" !== c.type ? console.error("Improper nesting of table.Your <td> should have a <tr> parent." + d(e)) : "th" === s && "tr" !== c.type && console.error("Improper nesting of table.Your <th> should have a <tr>." + d(e)) : console.error("Improper nesting of table.Your <thead/tbody/tfoot> should have a <table> parent." + d(e)), void 0 !== e.ref && "function" != typeof e.ref && "object" != typeof e.ref && !("$$typeof" in e)) throw new Error('Component\'s "ref" property should be a function, or an object created by createRef(), but got [' + typeof e.ref + "] instead\n" + d(e));if ("string" == typeof e.type) for (var h in e.props) {
        if ("o" === h[0] && "n" === h[1] && "function" != typeof e.props[h] && null != e.props[h]) throw new Error("Component's \"" + h + '" property should be a function, but got [' + typeof e.props[h] + "] instead\n" + d(e));
      }if ("function" == typeof e.type && e.type.propTypes) {
        if ("Lazy" === e.type.displayName && !u.lazyPropTypes[e.type]) {
          var p = "PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";try {
            var v = e.type();u.lazyPropTypes[e.type] = !0, console.warn(p + "Component wrapped in lazy() is " + (v.type.displayName || v.type.name));
          } catch (n) {
            console.warn(p + "We will log the wrapped component's name once it is loaded.");
          }
        }t = e.type.propTypes, o = e.props, a = i(e), l = d(e), Object.keys(t).forEach(function (n) {
          var e;try {
            e = t[n](o, n, l, a, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
          } catch (n) {
            e = n;
          }!e || e.message in r || (r[e.message] = !0, console.error("Failed " + a + " type: " + e.message));
        });
      }n && n(e);
    }
  }, _preact.options.__h = function (n) {
    if (!n) throw new Error("Hook can only be invoked from render methods.");
  };var l = function l(n, e) {
    return { get: function get() {
        throw new Error("getting vnode." + n + " is deprecated, " + e);
      }, set: function set() {
        throw new Error("setting vnode." + n + " is not allowed, " + e);
      } };
  },
      s = { nodeName: l("nodeName", "use vnode.type"), attributes: l("attributes", "use vnode.props"), children: l("children", "use vnode.props.children") };_preact.options.vnode = function (n) {
    var e, t;n.props && n.props.i && (e = n.props.i, delete n.props.i), n.props && n.props.u && (t = n.props.u, delete n.props.u), n.u = t, n.i = e, Object.defineProperties(n, s), o && o(n);
  }, _preact.options.diffed = function (n) {
    if (null != n) {
      if (n.__c && n.__c.l) {
        var t = n.__c.l;t.s.forEach(function (e) {
          !e.h || e.p && Array.isArray(e.p) || console.warn("In " + (n.type.name || n.type) + " you are calling useMemo/useCallback without passing arguments.\nThis is a noop since it will not be able to memoize, it will execute it every render.");
        }), t.v.length > 0 && t.v.forEach(function (e) {
          e.p && Array.isArray(e.p) || u.useEffect[n.type] || (u.useEffect[n.type] = !0, console.warn('You should provide an array of arguments as the second argument to the "useEffect" hook.\n\nNot doing so will invoke this effect on every render.\n\nThis effect can be found in the render of ' + (n.type.name || n.type) + "."));
        }), t.m.length > 0 && t.m.forEach(function (e) {
          e.p && Array.isArray(e.p) || u.useLayoutEffect[n.type] || (u.useLayoutEffect[n.type] = !0, console.warn('You should provide an array of arguments as the second argument to the "useLayoutEffect" hook.\n\nNot doing so will invoke this effect on every render.\n\nThis effect can be found in the render of ' + (n.type.name || n.type) + "."));
        });
      }if (null != n.__k) for (var r = [], o = 0; o < n.__k.length; o++) {
        var i = n.__k[o];if (i && null != i.key) {
          var a = i.key;if (-1 !== r.indexOf(a)) {
            console.error('Following component has two or more children with the same key attribute: "' + a + '". This may cause glitches and misbehavior in rendering process. Component: \n\n' + d(n));break;
          }r.push(a);
        }
      }e && e(n);
    }
  };
}(), function () {
  var r = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;if (null != r) {
    var o = v,
        i = v,
        a = Math.random().toString(16).slice(2),
        u = new h(r, a);p(function () {
      var n = !1;try {
        n = "production" !== process.env.NODE_ENV;
      } catch (n) {}window.parent.postMessage({ source: "react-devtools-detector", reactBuildType: n ? "development" : "production" }, "*");var t = { bundleType: n ? 1 : 0, version: "16.5.2", rendererPackageName: "preact", findHostInstanceByFiber: function findHostInstanceByFiber(n) {
          return n.__e;
        }, findFiberByHostInstance: function findFiberByHostInstance(n) {
          return u.inst2vnode.get(n) || null;
        } };r._renderers[a] = t, Object.defineProperty(r.helpers, a, { get: function get() {
          return u;
        }, set: function set() {
          u.connected || l.markConnected();
        } });var l = r.helpers[a];r.emit("renderer-attached", { id: a, renderer: t, helpers: l }), o = p(function (n) {
        if (n.type !== _preact.Fragment || 0 != n.__k.length) {
          var t = r.getFiberRoots(a);n = l.handleCommitFiberRoot(n), t.has(n) || t.add(n);
        }
      }), i = p(function (n) {
        r.onCommitFiberUnmount(a, n);
      });
    })();var l = _preact.options.vnode,
        s = _preact.options.__c,
        c = _preact.options.unmount,
        f = _preact.options.__b,
        d = _preact.options.diffed;_preact.options.vnode = function (n) {
      n.startTime = NaN, n.endTime = NaN, n.startTime = 0, n.endTime = -1, l && l(n);
    }, _preact.options.__b = function (n) {
      n.startTime = y(), null != f && f(n);
    }, _preact.options.diffed = function (n) {
      n.endTime = y(), null != d && d(n);
    }, _preact.options.__c = p(function (n) {
      null != s && s(n), null != n && o(n);
    }), _preact.options.unmount = p(function (n) {
      null != c && c(n), i(n);
    });var m = _preact.Component.prototype.setState;_preact.Component.prototype.setState = function (n, e) {
      var t = this.__s !== this.state && this.__s || (this.__s = Object.assign({}, this.state));return this.__u = Object.assign({}, t), m.call(this, n, e);
    };
  }
}());
//# sourceMappingURL=debug.module.js.map
"use strict";

!function (e, n) {
  "object" == typeof exports && "undefined" != typeof module ? n(require("preact")) : "function" == typeof define && define.amd ? define(["preact"], n) : n(e.preact);
}(undefined, function (e) {
  var n = {};function t(n) {
    return n.type === e.Fragment ? "Wrapper" : "function" == typeof n.type ? "Composite" : "string" == typeof n.type ? "Native" : "Text";
  }function r(n) {
    return n.type === e.Fragment ? "Fragment" : "function" == typeof n.type ? n.type.displayName || n.type.name : "string" == typeof n.type ? n.type : "#text";
  }function o(e, n, t) {
    var r = n.pop(),
        o = n.reduce(function (e, n) {
      return e ? e[n] : null;
    }, e);o && (o[r] = t);
  }function i(n) {
    var i = n.__c,
        u = null;null != i && i instanceof e.Component && (u = { setState: i.setState.bind(i), forceUpdate: i.forceUpdate.bind(i), setInState: function setInState(e, n) {
        i.setState(function (t) {
          return o(t, e, n), t;
        });
      }, setInProps: function setInProps(e, t) {
        o(n.props, e, t), i.setState({});
      }, setInContext: function setInContext(e, n) {
        o(i.context, e, n), i.setState({});
      } });var s = a(n),
        c = n.endTime - n.startTime;return { nodeType: t(n), type: n.type, name: r(n), ref: n.ref || null, key: n.key || null, updater: u, text: null === n.type ? n.props : null, state: null != i && i instanceof e.Component ? i.state : null, props: n.props, children: null !== n.type ? null != s && 1 == s.length && null === s[0].type ? s[0].props : s : null, publicInstance: l(n), memoizedInteractions: [], actualDuration: c, actualStartTime: n.startTime, treeBaseDuration: c };
  }function a(e) {
    return null == e.__c ? null != e.__k ? e.__k.filter(Boolean) : [] : null != e.__k ? e.__k.filter(Boolean) : null;
  }function u(n) {
    return n.type === e.Fragment && null === n.__p;
  }function l(n) {
    return u(n) ? n.__k.length > 0 && null != n.__k[0] && null != n.__k[0].__e ? n.__k[0].__e.parentNode : n : null != n.__c ? n.__c : n.type === e.Fragment ? n.props : n.__e;
  }function s(e, n, t) {
    if (null == e || null == n) return !1;for (var r in e) {
      if ((!t || "children" != r || null == n[r]) && e[r] !== n[r]) return !1;
    }return Object.keys(e).length === Object.keys(n).length;
  }function c(e) {
    var n = e.props,
        t = r(e),
        o = "";if (n) for (var i in n) {
      if (n.hasOwnProperty(i) && "children" !== i) {
        var a = n[i];"function" == typeof a && (a = "function " + (a.displayName || a.name) + "() {}"), a = Object(a) !== a || a.toString ? a + "" : Object.prototype.toString.call(a), o += " " + i + "=" + JSON.stringify(a);
      }
    }var u = n.children;return "<" + t + o + (u && u.length ? ">..</" + t + ">" : " />");
  }var f = function f(e, n) {
    this.rid = n, this.hook = e, this.pending = [], this.inst2vnode = new WeakMap(), this.connected = !1;
  };function d(e) {
    return function (n) {
      try {
        return e(n);
      } catch (e) {
        console.error("The react devtools encountered an error"), console.error(e);
      }
    };
  }f.prototype.markConnected = function () {
    this.connected = !0, this.flushPendingEvents();
  }, f.prototype.flushPendingEvents = function () {
    if (this.connected) {
      var e = this.pending;this.pending = [];for (var n = 0; n < e.length; n++) {
        var t = e[n];this.hook.emit(t.type, t);
      }
    }
  }, f.prototype.mount = function (e) {
    this.inst2vnode.set(l(e), e);var n = i(e),
        t = [{ internalInstance: e, data: n, renderer: this.rid, type: "mount" }];if (Array.isArray(n.children)) for (var r, o = n.children.slice(); null != (r = o.pop());) {
      var s = a(r);o.push.apply(o, s), this.inst2vnode.set(l(r), r);var c = i(r);t.push({ internalInstance: r, data: c, renderer: this.rid, type: "mount" });
    }for (var f = t.length; --f >= 0;) {
      this.pending.push(t[f]);
    }u(e) && this.pending.push({ internalInstance: e, data: n, renderer: this.rid, type: "root" });
  }, f.prototype.update = function (e) {
    var n = i(e);if (Array.isArray(n.children)) for (var t = 0; t < n.children.length; t++) {
      var r = n.children[t],
          o = l(r);null == this.inst2vnode.get(o) ? this.mount(r) : this.update(r), n.children[t] = this.inst2vnode.get(o);
    }var a = this.inst2vnode.get(n.publicInstance);!function (e, n) {
      return e.props !== n.props && !s(e.props, n.props, !0) || null != e.__c && !s(n.__c.__u, n.__c.state) || e.__e !== n.__e || e.ref !== n.ref;
    }(a, e) ? this.pending.push({ internalInstance: a, data: n, renderer: this.rid, type: "updateProfileTimes" }) : this.pending.push({ internalInstance: a, data: n, renderer: this.rid, type: "update" });
  }, f.prototype.handleCommitFiberRoot = function (e) {
    var n = l(e);this.inst2vnode.has(n) ? this.update(e) : this.mount(e);var t = null;if (u(e)) e.treeBaseDuration = 0, t = e;else for (t = e; null != t.__p;) {
      t = t.__p;
    }return this.pending.push({ internalInstance: t, renderer: this.rid, data: i(t), type: "rootCommitted" }), this.flushPendingEvents(), e;
  }, f.prototype.handleCommitFiberUnmount = function (e) {
    var n = l(e);this.inst2vnode.delete(n), this.pending.push({ internalInstance: e, renderer: this.rid, type: "unmount" });
  }, f.prototype.getNativeFromReactElement = function (e) {
    return e.__e;
  }, f.prototype.getReactElementFromNative = function (e) {
    return this.inst2vnode.get(e) || null;
  }, f.prototype.walkTree = function () {}, f.prototype.cleanup = function () {};var h = function h() {},
      p = Date.now;try {
    p = performance.now.bind(performance);
  } catch (e) {}"development" === process.env.NODE_ENV && (function () {
    var t = e.options.__b,
        o = e.options.diffed,
        i = e.options.vnode,
        a = e.options.__e,
        u = { useEffect: {}, useLayoutEffect: {}, lazyPropTypes: {} };e.options.__e = function (e, n, t) {
      if (n && n.__c && "function" == typeof e.then) {
        var o = e;e = new Error("Missing Suspense. The throwing component was: " + r(n));for (var i = n; i; i = i.__p) {
          if (i.__c && i.__c.t) {
            e = o;break;
          }
        }
      }a(e, n, t);
    }, e.options.__p = function (e, n) {
      if (!n) throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");var t;switch (n.nodeType) {case 1:case 11:case 9:
          t = !0;break;default:
          t = !1;}if (!t) throw new Error("\n\t\t\tExpected a valid HTML node as a second argument to render.\n\t\t\tReceived " + n + " instead: render(<" + (e.type.name || e.type) + " />, " + n + ");\n\t\t");
    }, e.options.__b = function (e) {
      if (null != e) {
        var o,
            i,
            a,
            l,
            s = e.type,
            f = function e(n) {
          return n ? "function" == typeof n.type ? e(n.__p) : n : {};
        }(e.__p);if (void 0 === s) throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports" + c(e));if (null != s && "object" == typeof s) {
          if (void 0 !== s.o && void 0 !== s.__e) {
            var d = "Did you accidentally pass a JSX literal as JSX twice?\n\n  let My" + r(s) + " = " + c(s) + ";\n  let vnode = <My" + r(s) + " />;\n\nThis usually happens when you export a JSX literal and not the component.";throw new Error("Invalid type passed to createElement(): " + s + "\n\n" + d + "\n");
          }throw new Error("Invalid type passed to createElement(): " + (Array.isArray(s) ? "array" : s));
        }if ("thead" !== s && "tfoot" !== s && "thead" !== s || "table" === f.type ? "tr" === s && "thead" !== f.type && "tfoot" !== f.type && "tbody" !== f.type && "table" !== f.type ? console.error("Improper nesting of table.Your <tr> should have a <thead/tbody/tfoot/table> parent." + c(e)) : "td" === s && "tr" !== f.type ? console.error("Improper nesting of table.Your <td> should have a <tr> parent." + c(e)) : "th" === s && "tr" !== f.type && console.error("Improper nesting of table.Your <th> should have a <tr>." + c(e)) : console.error("Improper nesting of table.Your <thead/tbody/tfoot> should have a <table> parent." + c(e)), void 0 !== e.ref && "function" != typeof e.ref && "object" != typeof e.ref && !("$$typeof" in e)) throw new Error('Component\'s "ref" property should be a function, or an object created by createRef(), but got [' + typeof e.ref + "] instead\n" + c(e));if ("string" == typeof e.type) for (var h in e.props) {
          if ("o" === h[0] && "n" === h[1] && "function" != typeof e.props[h] && null != e.props[h]) throw new Error("Component's \"" + h + '" property should be a function, but got [' + typeof e.props[h] + "] instead\n" + c(e));
        }if ("function" == typeof e.type && e.type.propTypes) {
          if ("Lazy" === e.type.displayName && !u.lazyPropTypes[e.type]) {
            var p = "PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";try {
              var v = e.type();u.lazyPropTypes[e.type] = !0, console.warn(p + "Component wrapped in lazy() is " + (v.type.displayName || v.type.name));
            } catch (e) {
              console.warn(p + "We will log the wrapped component's name once it is loaded.");
            }
          }o = e.type.propTypes, i = e.props, a = r(e), l = c(e), Object.keys(o).forEach(function (e) {
            var t;try {
              t = o[e](i, e, l, a, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (e) {
              t = e;
            }!t || t.message in n || (n[t.message] = !0, console.error("Failed " + a + " type: " + t.message));
          });
        }t && t(e);
      }
    }, e.options.__h = function (e) {
      if (!e) throw new Error("Hook can only be invoked from render methods.");
    };var l = function l(e, n) {
      return { get: function get() {
          throw new Error("getting vnode." + e + " is deprecated, " + n);
        }, set: function set() {
          throw new Error("setting vnode." + e + " is not allowed, " + n);
        } };
    },
        s = { nodeName: l("nodeName", "use vnode.type"), attributes: l("attributes", "use vnode.props"), children: l("children", "use vnode.props.children") };e.options.vnode = function (e) {
      var n, t;e.props && e.props.i && (n = e.props.i, delete e.props.i), e.props && e.props.u && (t = e.props.u, delete e.props.u), e.u = t, e.i = n, Object.defineProperties(e, s), i && i(e);
    }, e.options.diffed = function (e) {
      if (null != e) {
        if (e.__c && e.__c.l) {
          var n = e.__c.l;n.s.forEach(function (n) {
            !n.h || n.p && Array.isArray(n.p) || console.warn("In " + (e.type.name || e.type) + " you are calling useMemo/useCallback without passing arguments.\nThis is a noop since it will not be able to memoize, it will execute it every render.");
          }), n.v.length > 0 && n.v.forEach(function (n) {
            n.p && Array.isArray(n.p) || u.useEffect[e.type] || (u.useEffect[e.type] = !0, console.warn('You should provide an array of arguments as the second argument to the "useEffect" hook.\n\nNot doing so will invoke this effect on every render.\n\nThis effect can be found in the render of ' + (e.type.name || e.type) + "."));
          }), n.m.length > 0 && n.m.forEach(function (n) {
            n.p && Array.isArray(n.p) || u.useLayoutEffect[e.type] || (u.useLayoutEffect[e.type] = !0, console.warn('You should provide an array of arguments as the second argument to the "useLayoutEffect" hook.\n\nNot doing so will invoke this effect on every render.\n\nThis effect can be found in the render of ' + (e.type.name || e.type) + "."));
          });
        }if (null != e.__k) for (var t = [], r = 0; r < e.__k.length; r++) {
          var i = e.__k[r];if (i && null != i.key) {
            var a = i.key;if (-1 !== t.indexOf(a)) {
              console.error('Following component has two or more children with the same key attribute: "' + a + '". This may cause glitches and misbehavior in rendering process. Component: \n\n' + c(e));break;
            }t.push(a);
          }
        }o && o(e);
      }
    };
  }(), function () {
    var n = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;if (null != n) {
      var t = h,
          r = h,
          o = Math.random().toString(16).slice(2),
          i = new f(n, o);d(function () {
        var a = !1;try {
          a = "production" !== process.env.NODE_ENV;
        } catch (e) {}window.parent.postMessage({ source: "react-devtools-detector", reactBuildType: a ? "development" : "production" }, "*");var u = { bundleType: a ? 1 : 0, version: "16.5.2", rendererPackageName: "preact", findHostInstanceByFiber: function findHostInstanceByFiber(e) {
            return e.__e;
          }, findFiberByHostInstance: function findFiberByHostInstance(e) {
            return i.inst2vnode.get(e) || null;
          } };n._renderers[o] = u, Object.defineProperty(n.helpers, o, { get: function get() {
            return i;
          }, set: function set() {
            i.connected || l.markConnected();
          } });var l = n.helpers[o];n.emit("renderer-attached", { id: o, renderer: u, helpers: l }), t = d(function (t) {
          if (t.type !== e.Fragment || 0 != t.__k.length) {
            var r = n.getFiberRoots(o);t = l.handleCommitFiberRoot(t), r.has(t) || r.add(t);
          }
        }), r = d(function (e) {
          n.onCommitFiberUnmount(o, e);
        });
      })();var a = e.options.vnode,
          u = e.options.__c,
          l = e.options.unmount,
          s = e.options.__b,
          c = e.options.diffed;e.options.vnode = function (e) {
        e.startTime = NaN, e.endTime = NaN, e.startTime = 0, e.endTime = -1, a && a(e);
      }, e.options.__b = function (e) {
        e.startTime = p(), null != s && s(e);
      }, e.options.diffed = function (e) {
        e.endTime = p(), null != c && c(e);
      }, e.options.__c = d(function (e) {
        null != u && u(e), null != e && t(e);
      }), e.options.unmount = d(function (e) {
        null != l && l(e), r(e);
      });var v = e.Component.prototype.setState;e.Component.prototype.setState = function (e, n) {
        var t = this.__s !== this.state && this.__s || (this.__s = Object.assign({}, this.state));return this.__u = Object.assign({}, t), v.call(this, e, n);
      };
    }
  }());
});
//# sourceMappingURL=debug.umd.js.map
'use strict';

/* eslint-disable no-console */

if (process.env.NODE_ENV === 'development') {
	var preact = require('preact');
	var options = preact.options;
	var oldVnodeOption = options.vnode;

	options.vnode = function (vnode) {
		var nodeName = vnode.nodeName,
		    attributes = vnode.attributes,
		    children = vnode.children;


		if (nodeName === void 0) {
			console.error('Undefined component passed to preact.h()\n' + serializeVNode(vnode));
		}

		if (attributes && attributes.ref !== void 0 && typeof attributes.ref !== 'function' && typeof attributes.ref !== 'object' && !('$$typeof' in vnode) // allow string refs when preact-compat is installed
		) {
				throw new Error('Component\'s "ref" property should be a function or createRef() object,' + (' but [' + typeof attributes.ref + '] passed\n') + serializeVNode(vnode));
			}

		{
			var keys = {};

			inspectChildren(children, function (deepChild) {
				if (!deepChild || deepChild.key == null) return;

				// In Preact, all keys are stored as object values, i.e. being strings
				var key = deepChild.key + '';

				if (keys.hasOwnProperty(key)) {
					console.error('Following component has two or more children with the ' + 'same "key" attribute. This may cause glitches and misbehavior ' + 'in rendering process. Component: \n\n' + serializeVNode(vnode));

					// Return early to not spam the console
					return true;
				}

				keys[key] = true;
			});
		}

		if (oldVnodeOption) oldVnodeOption.call(this, vnode);
	};

	try {
		var oldRender = preact.render;
		preact.render = function (vnode, parent, merge) {
			if (parent == null && merge == null) {
				// render(vnode, parent, merge) can't have both parent and merge be undefined
				console.error('The "containerNode" or "replaceNode" is not defined in the render method. ' + 'Component: \n\n' + serializeVNode(vnode));
			} else if (parent == merge) {
				// if parent == merge, it doesn't reason well and would cause trouble when preact
				// tries to update or replace that 'replaceNode' element
				console.error('The "containerNode" and "replaceNode" are the same in render method, ' + 'when the "replaceNode" DOM node is expected to be a child of "containerNode". ' + 'docs-ref: https://preactjs.com/guide/api-reference#-preact-render-. Component: \n\n' + serializeVNode(vnode));
			}
			return oldRender(vnode, parent, merge);
		};
	} catch (e) {}

	var inspectChildren = function inspectChildren(children, inspect) {
		if (!Array.isArray(children)) {
			children = [children];
		}
		return children.some(function (child, i) {
			if (Array.isArray(child)) {
				return inspectChildren(child, inspect);
			}

			return inspect(child, i);
		});
	};

	var serializeVNode = function serializeVNode(_ref) {
		var nodeName = _ref.nodeName,
		    attributes = _ref.attributes,
		    children = _ref.children;

		if (typeof nodeName === 'function') {
			nodeName = nodeName.name || nodeName.displayName;
		}

		var props = '';
		if (attributes) {
			for (var attr in attributes) {
				if (attributes.hasOwnProperty(attr) && attr !== 'children') {
					var value = attributes[attr];

					// If it is an object but doesn't have toString(), use Object.toString
					if (typeof value === 'function') {
						value = 'function ' + (value.displayName || value.name) + '() {}';
					}
					if (Object(value) === value && !value.toString) {
						value = Object.prototype.toString.call(value);
					} else {
						value = value + '';
					}

					props += ' ' + attr + '=' + JSON.stringify(value);
				}
			}
		}

		return '<' + nodeName + props + (children && children.length ? '>..</' + nodeName + '>' : ' />');
	};

	require('preact/devtools');
}

//# sourceMappingURL=debug.js.map